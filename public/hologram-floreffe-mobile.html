<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>üåç TINSFLASH ‚Äì D√¥me Floreffe Mobile</title>
  <style>
    html, body { margin:0; padding:0; overflow:hidden; background:black; height:100%; }
    canvas { display:block; width:100%; height:100%; touch-action:none; }
    #hud {
      position:absolute; top:8px; left:8px;
      background:rgba(0,0,0,0.6); color:#0ff;
      padding:6px 10px; border-radius:8px;
      font-family:monospace; font-size:13px;
      z-index:10;
    }
    #castBtn {
      position:absolute; bottom:15px; right:15px;
      background:rgba(0,255,255,0.15);
      border:1px solid #0ff; border-radius:50%;
      color:#0ff; font-size:22px;
      width:50px; height:50px; cursor:pointer;
      display:flex; align-items:center; justify-content:center;
      z-index:10;
    }
  </style>
</head>
<body>
  <div id="hud">Initialisation du d√¥me holographique‚Ä¶</div>
  <div id="castBtn">üì∫</div>

  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.161/build/three.module.js";
    import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.161/examples/jsm/controls/OrbitControls.js";

    const hud = document.getElementById("hud");
    const forecastsURL = "./floreffe_forecasts.json";
    const alertsURL = "./floreffe_alerts.json";

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 2000);
    camera.position.set(0, 60, 220);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.enableZoom = true;
    controls.enablePan = false;

    const amb = new THREE.AmbientLight(0x88ffff, 1.0);
    const dir = new THREE.DirectionalLight(0xffffff, 0.6);
    dir.position.set(0, 100, 100);
    scene.add(amb, dir);

    const globeGeo = new THREE.SphereGeometry(80, 64, 64);
    const globeMat = new THREE.MeshPhongMaterial({ color:0x004466, emissive:0x002233, shininess:20 });
    const globe = new THREE.Mesh(globeGeo, globeMat);
    scene.add(globe);

    const alertGroup = new THREE.Group();
    scene.add(alertGroup);

    async function loadData() {
      try {
        hud.textContent = "Chargement des pr√©visions Floreffe‚Ä¶";
        const forecasts = await (await fetch(forecastsURL)).json();
        const alerts = await (await fetch(alertsURL)).json();

        hud.textContent = `Pr√©visions: ${forecasts?.zones?.length ?? 0} pts ¬∑ Alertes: ${alerts?.alerts?.length ?? 0}`;

        for (const z of forecasts?.zones ?? []) {
          const phi = (90 - (z.lat || 50.4)) * Math.PI / 180;
          const theta = (z.lon || 4.7) * Math.PI / 180;
          const r = 80;
          const x = r * Math.sin(phi) * Math.cos(theta);
          const y = r * Math.cos(phi);
          const zz = r * Math.sin(phi) * Math.sin(theta);
          const color = (z.precipitation > 20) ? 0x00ffff : 0x00ff88;
          const sphere = new THREE.Mesh(
            new THREE.SphereGeometry(1.5, 8, 8),
            new THREE.MeshBasicMaterial({ color })
          );
          sphere.position.set(x, y, zz);
          scene.add(sphere);
        }

        for (const a of alerts?.alerts ?? []) {
          const torus = new THREE.Mesh(
            new THREE.TorusGeometry(2.5, 0.4, 8, 16),
            new THREE.MeshBasicMaterial({ color:0xff0000 })
          );
          torus.position.set(Math.random()*100-50, Math.random()*80-40, Math.random()*100-50);
          alertGroup.add(torus);
        }

      } catch (e) {
        hud.textContent = "‚ùå Erreur : " + e.message;
      }
    }

    loadData();

    function animate() {
      requestAnimationFrame(animate);
      globe.rotation.y += 0.001;
      alertGroup.rotation.y -= 0.002;
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    const castBtn = document.getElementById("castBtn");
    castBtn.onclick = () => {
      if (document.pictureInPictureEnabled && !document.pictureInPictureElement) {
        renderer.domElement.requestPictureInPicture().catch(()=>{});
      } else if (document.pictureInPictureElement) {
        document.exitPictureInPicture().catch(()=>{});
      }
    };

    window.addEventListener("resize", () => {
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
  </script>
</body>
</html>
