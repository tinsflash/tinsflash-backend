<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>TINSFLASH â€“ Hologram Floreffe (mobile)</title>
  <style>
    html, body { margin: 0; padding: 0; overflow: hidden; background: black; height: 100%; }
    canvas { display: block; width: 100%; height: 100%; touch-action: none; }
    #hud {
      position: absolute; top: 8px; left: 8px;
      background: rgba(0,0,0,0.6); color: #0ff;
      padding: 6px 10px; border-radius: 8px;
      font-family: monospace; font-size: 13px;
      z-index: 10;
    }
    #castBtn {
      position: absolute; bottom: 15px; right: 15px;
      background: rgba(0,255,255,0.15); border: 1px solid #0ff;
      border-radius: 50%; color: #0ff; font-size: 22px;
      width: 50px; height: 50px; cursor: pointer;
      display: flex; align-items: center; justify-content: center;
      z-index: 10;
    }
  </style>
</head>
<body>
  <div id="hud">Initialisation du dÃ´me holographiqueâ€¦</div>
  <div id="castBtn">ðŸ“º</div>

  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.161/build/three.module.js";
    import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.161/examples/jsm/controls/OrbitControls.js";

    const hud = document.getElementById("hud");
    const forecastsURL = "https://tinsflash-backend.onrender.com/floreffe_forecasts.json";
    const alertsURL = "https://tinsflash-backend.onrender.com/floreffe_alerts.json";

    // === WebSocket Render-safe ===
    let socket = { send:()=>{} };
    try {
      const s = new WebSocket(`wss://${window.location.host}/ws/hologram`);
      s.onopen = ()=>console.log("WS connectÃ©");
      s.onerror = ()=>console.warn("WS dÃ©sactivÃ© (Render non configurÃ©)");
      socket = s;
    } catch(e){ console.warn("WS inactif"); }

    // === Three.js Scene ===
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 2000);
    camera.position.set(0, 60, 220);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.enableZoom = true;
    controls.enablePan = false;

    // LumiÃ¨res et base visuelle
    const amb = new THREE.AmbientLight(0x88ffff, 1.0);
    const dir = new THREE.DirectionalLight(0xffffff, 0.6);
    dir.position.set(0, 100, 100);
    scene.add(amb, dir);

    const globeGeo = new THREE.SphereGeometry(80, 64, 64);
    const globeMat = new THREE.MeshPhongMaterial({
      color: 0x004466, emissive: 0x002233, shininess: 20,
      wireframe: false
    });
    const globe = new THREE.Mesh(globeGeo, globeMat);
    scene.add(globe);

    const alertGroup = new THREE.Group();
    scene.add(alertGroup);

    async function loadData() {
      try {
        hud.textContent = "Chargement des prÃ©visions Floreffeâ€¦";
        const forecasts = await (await fetch(forecastsURL)).json();
        const alerts = await (await fetch(alertsURL)).json();

        hud.textContent = `PrÃ©visions: ${forecasts?.zones?.length ?? 0} points Â· Alertes: ${alerts?.alerts?.length ?? 0}`;

        // Ajout points mÃ©tÃ©o
        for (const z of forecasts?.zones ?? []) {
          const phi = (90 - (z.lat || 50.4)) * Math.PI/180;
          const theta = (z.lon || 4.7) * Math.PI/180;
          const r = 80;
          const x = r * Math.sin(phi) * Math.cos(theta);
          const y = r * Math.cos(phi);
          const zz = r * Math.sin(phi) * Math.sin(theta);

          const color = (z.temperature > 25) ? 0xff6600 :
                        (z.temperature < 0) ? 0x00aaff : 0x00ff88;
          const point = new THREE.Mesh(
            new THREE.SphereGeometry(1.2, 8, 8),
            new THREE.MeshBasicMaterial({ color })
          );
          point.position.set(x, y, zz);
          scene.add(point);
        }

        // Ajout alertes visuelles
        for (const a of alerts?.alerts ?? []) {
          const mesh = new THREE.Mesh(
            new THREE.TorusGeometry(2.5, 0.4, 8, 16),
            new THREE.MeshBasicMaterial({ color: 0xff0000 })
          );
          mesh.position.set(Math.random()*100-50, Math.random()*100-50, Math.random()*100-50);
          alertGroup.add(mesh);
        }

      } catch (e) {
        hud.textContent = "Erreur chargement donnÃ©es : " + e.message;
      }
    }

    loadData();

    // === Animation loop ===
    function animate() {
      requestAnimationFrame(animate);
      globe.rotation.y += 0.001;
      alertGroup.rotation.y -= 0.002;
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    // === Cast TV simulation ===
    const castBtn = document.getElementById("castBtn");
    castBtn.onclick = () => {
      if (document.pictureInPictureEnabled && !document.pictureInPictureElement) {
        renderer.domElement.requestPictureInPicture().catch(()=>{});
      } else if (document.pictureInPictureElement) {
        document.exitPictureInPicture().catch(()=>{});
      }
    };

    window.addEventListener("resize", () => {
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
  </script>
</body>
</html>
