<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>TINSFLASH ‚Äì D√¥me holographique Floreffe</title>
<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.160.0/examples/js/controls/OrbitControls.js"></script>
<style>
html,body{margin:0;padding:0;overflow:hidden;background:#000;color:#7de0ff;font-family:Segoe UI,Arial}
#info{position:fixed;top:10px;left:10px;background:rgba(0,0,0,.4);padding:8px 12px;border-radius:6px;font-size:14px;}
</style>
</head>
<body>
<div id="info">üåç D√¥me Floreffe ‚Äì Mode test local (JSON)</div>
<canvas id="scene"></canvas>

<script>
let scene,camera,renderer,controls,terrainMesh,alertGroup;

init();
animate();

async function init(){
  const canvas=document.getElementById("scene");
  renderer=new THREE.WebGLRenderer({canvas,antialias:true});
  renderer.setSize(window.innerWidth,window.innerHeight);
  scene=new THREE.Scene();
  camera=new THREE.PerspectiveCamera(45,window.innerWidth/window.innerHeight,1,2000);
  camera.position.set(0,150,250);
  controls=new THREE.OrbitControls(camera,renderer.domElement);
  controls.autoRotate=true;
  controls.autoRotateSpeed=0.6;
  controls.enableDamping=true;

  // Halo
  const haloGeom=new THREE.RingGeometry(120,130,64);
  const haloMat=new THREE.MeshBasicMaterial({color:0x33ccff,side:THREE.DoubleSide,transparent:true,opacity:0.2});
  const halo=new THREE.Mesh(haloGeom,haloMat);
  halo.rotation.x=Math.PI/2;
  scene.add(halo);

  // Lumi√®re
  const light=new THREE.PointLight(0x66ccff,1.5,600);
  light.position.set(0,200,0);
  scene.add(light);

  scene.add(new THREE.AmbientLight(0x447799,0.4));

  // Charger relief
  const alt=await fetch("floreffe_altitudes.json").then(r=>r.json());
  createTerrain(alt);

  // Charger alertes
  const alerts=await fetch("floreffe_alerts.json").then(r=>r.json());
  renderAlerts(alerts);

  window.addEventListener("resize",onResize);
}

function createTerrain(points){
  const geometry=new THREE.PlaneGeometry(240,240,30,30);
  geometry.rotateX(-Math.PI/2);
  // Interpolation simple : hauteur par proximit√©
  geometry.verticesNeedUpdate=true;
  const pos=geometry.attributes.position;
  for(let i=0;i<pos.count;i++){
    const vx=pos.getX(i)/2+50.44; // approx centre Floreffe
    const vz=pos.getZ(i)/2+4.76;
    const closest=points.reduce((a,b)=>{
      const da=(vx-b.lat)**2+(vz-b.lon)**2;
      const db=(vx-a.lat)**2+(vz-a.lon)**2;
      return da<db?b:a;
    });
    const h=(closest.alt-80)/2; // √©l√©vation relative
    pos.setY(i,h);
  }
  pos.needsUpdate=true;
  const mat=new THREE.MeshBasicMaterial({
    color:0x33ccff,wireframe:true,transparent:true,opacity:0.6
  });
  terrainMesh=new THREE.Mesh(geometry,mat);
  scene.add(terrainMesh);
}

function renderAlerts(list){
  alertGroup=new THREE.Group();
  list.forEach(a=>{
    const geom=new THREE.SphereGeometry(2,12,12);
    const col=a.level==="rouge"?0xff3333:0xff9900;
    const mat=new THREE.MeshBasicMaterial({color:col,transparent:true,opacity:0.9});
    const s=new THREE.Mesh(geom,mat);
    s.position.set((a.lat-50.44)*2,(a.alt-80)/2,(a.lon-4.76)*2);
    alertGroup.add(s);
  });
  scene.add(alertGroup);
}

function animate(){
  requestAnimationFrame(animate);
  controls.update();
  if(alertGroup){
    const t=Date.now()*0.003;
    alertGroup.children.forEach((s,i)=>{
      s.scale.setScalar(1+0.2*Math.sin(t+i));
      s.material.opacity=0.5+0.4*Math.abs(Math.sin(t+i));
    });
  }
  renderer.render(scene,camera);
}

function onResize(){
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
}
</script>
</body>
</html>
