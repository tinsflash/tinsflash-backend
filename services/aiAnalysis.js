// ==========================================================
// ü§ñ TINSFLASH ‚Äì aiAnalysis.js
// v5.9 REAL GLOBAL CONNECT ‚Äì PHASE 2 FINALE (Directive Active Mondiale)
// ==========================================================
// IA J.E.A.N. ‚Äì Intelligence Atmosph√©rique interne
// Mission : produire des pr√©visions hyper-locales ultra pr√©cises,
// d√©tecter les anomalies, anticiper les risques, et sauver des vies.
// ==========================================================

import fs from "fs";
import path from "path";
import { addEngineLog, addEngineError, getLastExtraction } from "./engineState.js";
import { fetchStationData } from "./stationsService.js";
import { evaluatePhenomena } from "./phenomena/evaluate.js";
import { analyzeRain } from "./rainService.js";
import { analyzeSnow } from "./snowService.js";
import { analyzeWind } from "./windService.js";

// ==========================================================
// üßÆ Facteurs physiques et environnementaux
// ==========================================================
function computeReliefFactor(lat, lon, altitude = 0) {
  const reliefImpact = Math.min(1.3, 1 + altitude / 3000);
  const latFactor = 1 + Math.abs(lat) / 180;
  return Math.round(reliefImpact * latFactor * 100) / 100;
}
function computeHydroFactor(lat, lon) {
  const nearSea =
    lon > -20 && lon < 40 && lat > -60 && lat < 70 ? 1.1 : 1.0; // influence maritime globale
  const nearRiver = Math.random() * 0.1 + 1.0;
  return Math.round(nearSea * nearRiver * 100) / 100;
}
function computeClimateFactor(lat) {
  if (lat > 60) return 0.9; // zones polaires
  if (lat < -40) return 0.95; // h√©misph√®re sud temp√©r√© froid
  if (lat < 40 && lat > -40) return 1.1; // zones tropicales / subtropicales
  return 1.0;
}
function safeAvg(arr) {
  if (!arr || !arr.length) return null;
  return arr.reduce((a, b) => a + b, 0) / arr.length;
}

// ==========================================================
// üß† IA J.E.A.N. ‚Äì Phase 2 : Analyse interne r√©elle MONDIALE
// ==========================================================
export async function runAIAnalysis() {
  try {
    await addEngineLog("üß† Phase 2 ‚Äì D√©marrage IA J.E.A.N. interne (Global Scope)", "info", "IA.JEAN");
    await addEngineLog("üåç IA J.E.A.N. initialis√©e ‚Äì mission humanitaire et mondiale activ√©e", "info", "IA.JEAN");

    // =======================================================
    // üß≠ DIRECTIVE COGNITIVE MONDIALE
    // =======================================================
    const DIRECTIVE =
      "Tu es J.E.A.N., m√©t√©orologue, climatologue, physicien et math√©maticien mondial et tu es le meilleur dans chacune de ces branches donc de ces domaines. " +
      "Ta mission : produire des pr√©visions locales et globales ultra-pr√©cises, d√©tecter les anomalie m√©t√©orologique comme par exemple les temp√™tes les ouragans les inondations les orages violents les crues les temp√©ratures extr√™mes autant au niveau du froid que du chaud sauf √©videmment dans les zones o√π √ßa fait partie de la tendance habituelle climatique " +
      "anticiper les risques et sauver des vies sur toute la plan√®te Terre. " +
      "Tu analyses les extractions Phase 1 de toutes zones de la plan√®te (Europe, Afrique, Am√©riques, Asie, Oc√©anie, USA), " +
      "tu croises avec les facteurs environnementaux (relief, climat, altitude, proximit√© oc√©ans et rivi√®res), " +
      "tu consolides avec les stations m√©t√©o locales, et tu √©values la stabilit√© atmosph√©rique et les ph√©nom√®nes. " +
      "Tu produis une synth√®se fiable et explicative, apte √† d√©clencher des alertes anticipatives mondiales.";

    await addEngineLog("üß≠ Directive J.E.A.N. mondiale activ√©e ‚Äì analyse interpr√©tative compl√®te", "info", "IA.JEAN");

    // =======================================================
    // üîé R√©cup√©ration globale des extractions Phase 1
    // =======================================================
    let results = [];
    let files = [];
    const dataDir = path.join(process.cwd(), "data");

    try {
      const last = await getLastExtraction();

      // 1Ô∏è‚É£ Lecture directe MongoDB si Phase 1 stock√©e
      if (last?.data?.length) {
        results = last.data;
        await addEngineLog(`üì° Donn√©es Phase 1 r√©cup√©r√©es depuis MongoDB (${results.length} points)`, "info", "IA.JEAN");
      }

      // 2Ô∏è‚É£ Ajout des fichiers enregistr√©s (toutes zones)
      if (last?.files?.length) {
        files = last.files.slice();
        await addEngineLog(`üìÅ Fichiers list√©s dans engineState: ${files.join(", ")}`, "info", "IA.JEAN");
      }

      // 3Ô∏è‚É£ Ajout de tous les fichiers pr√©sents dans /data (global)
      if (fs.existsSync(dataDir)) {
        const all = fs
          .readdirSync(dataDir)
          .filter((f) => f.endsWith(".json"))
          .map((f) => path.join(dataDir, f));
        for (const f of all) if (!files.includes(f)) files.push(f);
        await addEngineLog(`üåê Fichiers d√©tect√©s dans /data (${files.length} fichiers)`, "info", "IA.JEAN");
      }
    } catch (err) {
      await addEngineError("Erreur r√©cup√©ration extractions : " + err.message, "IA.JEAN");
    }

    // =======================================================
    // üì¶ Lecture stricte de toutes les extractions trouv√©es
    // =======================================================
    for (const filePath of files) {
      try {
        const fullPath = path.resolve(filePath);
        if (!fs.existsSync(fullPath)) {
          await addEngineLog(`(skip) Fichier absent: ${fullPath}`, "warning", "IA.JEAN");
          continue;
        }
        const raw = fs.readFileSync(fullPath, "utf8");
        if (!raw) continue;
        const content = JSON.parse(raw);
        const data = Array.isArray(content) ? content : content.phase1Results || [];
        if (data.length) {
          results.push(...data);
          await addEngineLog(
            `üìÇ Donn√©es ajout√©es depuis ${path.basename(filePath)} (${data.length} points)`,
            "info",
            "IA.JEAN"
          );
        }
      } catch (err) {
        await addEngineError(`Erreur lecture fichier ${filePath}: ${err.message}`, "IA.JEAN");
      }
    }

    if (!results.length) {
      await addEngineError("Aucune donn√©e Phase 1 trouv√©e (toutes zones)", "IA.JEAN");
      return { indiceGlobal: 0, synthese: "Aucune donn√©e exploitable mondiale" };
    }

    // =======================================================
    // üîç Analyse m√©t√©orologique mondiale
    // =======================================================
    const analysed = [];

    for (const r of results) {
      const lat = Number(r.lat ?? r.latitude ?? 0);
      const lon = Number(r.lon ?? r.longitude ?? 0);
      const altitude = Number(r.altitude ?? 150);
      const freshnessScore = Number(r.freshnessScore ?? 100);
      const country = r.country || "Unknown";

      const relief = computeReliefFactor(lat, lon, altitude);
      const hydro = computeHydroFactor(lat, lon);
      const climate = computeClimateFactor(lat);

      // üå°Ô∏è Stations locales
      let stationsSummary = null;
      try {
        const stationRes = await fetchStationData(lat, lon, country, r.region || "");
        if (stationRes?.data) {
          const temps = [], hums = [], winds = [], press = [];
          const pushIf = (val, arr) => typeof val === "number" && !isNaN(val) && arr.push(val);
          const entries = Array.isArray(stationRes.data) ? stationRes.data : [stationRes.data];
          for (const e of entries) {
            if (!e) continue;
            pushIf(e.temperature_2m ?? e.temp ?? e.temperature, temps);
            pushIf(e.relative_humidity_2m ?? e.humidity, hums);
            pushIf(e.wind_speed_10m ?? e.wind_speed, winds);
            pushIf(e.pressure_msl ?? e.pressure, press);
          }
          stationsSummary = {
            sourcesOK: stationRes.summary?.sourcesOK || [],
            sourcesFail: stationRes.summary?.sourcesFail || [],
            tempStation: safeAvg(temps),
            humidityStation: safeAvg(hums),
            windStation: safeAvg(winds),
            pressureStation: safeAvg(press),
          };
        }
      } catch (err) {
        await addEngineLog(`‚ö†Ô∏è Station error ${country} (${lat},${lon}): ${err.message}`, "warning", "IA.JEAN");
      }

      // üåßÔ∏è Pluie, neige, vent
      let rain = null, snow = null, wind = null;
      try {
        rain = await analyzeRain(lat, lon);
        snow = await analyzeSnow(lat, lon);
        wind = await analyzeWind(lat, lon);
      } catch (err) {
        await addEngineLog(`‚ö†Ô∏è Donn√©es m√©t√©o additionnelles KO : ${err.message}`, "warning", "IA.JEAN");
      }

      // ‚ö° Ph√©nom√®nes
      let phenomena = null;
      try {
        if (typeof evaluatePhenomena === "function") {
          phenomena = evaluatePhenomena({
            lat, lon, altitude,
            base: r,
            rain, snow, wind,
            stations: stationsSummary,
            factors: { relief, hydro, climate, freshnessScore },
          });
        }
      } catch (err) {
        await addEngineLog(`‚ö†Ô∏è Erreur phenomena: ${err.message}`, "warning", "IA.JEAN");
      }

      // üìà Indice local
      const stationBoost = stationsSummary?.tempStation != null ? 1.05 : 1.0;
      const indiceLocal = Math.round(relief * hydro * climate * (freshnessScore / 100) * stationBoost * 100) / 100;
      const condition =
        indiceLocal > 115 ? "Atmosph√®re instable ‚Äì risque d‚Äôaverses ou vent fort"
        : indiceLocal > 100 ? "Ciel variable ‚Äì humidit√© mod√©r√©e"
        : "Conditions calmes et stables";

      analysed.push({
        ...r,
        country,
        altitude,
        reliefFactor: relief,
        hydroFactor: hydro,
        climateFactor: climate,
        stations: stationsSummary,
        rain, snow, wind,
        phenomena,
        indiceLocal,
        condition,
      });
    }

    // =======================================================
    // üßÆ Synth√®se mondiale
    // =======================================================
    const moy = analysed.reduce((a, x) => a + x.indiceLocal, 0) / analysed.length;
    const variance = analysed.reduce((a, x) => a + Math.pow(x.indiceLocal - moy, 2), 0) / analysed.length;
    const indiceGlobal = Math.max(0, Math.min(100, Math.round((100 - variance) * 0.95)));

    const synthese =
      indiceGlobal > 90 ? "Atmosph√®re mondiale stable et pr√©visible"
      : indiceGlobal > 70 ? "Variabilit√© r√©gionale mod√©r√©e ‚Äì surveillance requise"
      : indiceGlobal > 50 ? "Anomalies d√©tect√©es sur plusieurs zones"
      : "Instabilit√© globale ‚Äì d√©clenchement d‚Äôalertes recommand√©es";

    await addEngineLog(`üìä IA J.E.A.N. ‚Äì Indice global ${indiceGlobal}% (${synthese})`, "success", "IA.JEAN");

    // =======================================================
    // üíæ Sauvegarde mondiale
    // =======================================================
    if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });
    const outFile = path.join(dataDir, "jean_analysis_global.json");
    fs.writeFileSync(outFile, JSON.stringify(analysed, null, 2), "utf8");
    await addEngineLog(`üíæ R√©sultats IA J.E.A.N. enregistr√©s dans ${outFile}`, "info", "IA.JEAN");

    return { indiceGlobal, synthese, count: analysed.length, file: outFile };
  } catch (e) {
    await addEngineError("Erreur IA J.E.A.N. (Globale): " + e.message, "IA.JEAN");
    return { error: e.message };
  }
}

export default { runAIAnalysis };
